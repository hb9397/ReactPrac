[react_prac2]

1. 컴포넌트 반복
    => 동일한 모양의 컴포넌트를 여러개 배치
    => 배열 형태의 데이터를 출력할 때 유용하게 사용

    1) 배열.map() [변환]
    
        => 배열의 데이터를 순회하면서 매개변수로 받은 함수를 요소 단위로 수행한 후 그 결과를 모아서 다시 배열로 반환하는 함수이다.

        => .map()에 설정하는 매개 변수는 2개다.

            -> 첫번째는 callback 함수로 필수요소 이다.
                - callback 함수의 매개변수는 3개까지 될 수 있고 반드시 하나의 데이터를 반환해야한다.

                - 첫번째 매개 변수는 순회하는 각 요소
                - 두번째 매개 변수는 인덱스
                - 세번째 매개 변수는 배열 그 자체

            -> 두번째는 callback 함수 내부에서 사용할 this 참조로 선택요소이다.

    P.S 배열 작업시 속도 올리려면 map, filter, reduce, for each를 사용해라.

    Ex> let ar = [10, 20, 30] 에서 위의 배열에 5를 더한 배열을 생성한다.

        -> for(let i=0; i<ar.length; i++){
                ar[i] = ar[i] + 5;
            }
        -> React에서는 props나 state 값을 수정할 수 없기 때문에 이런 구조가 성립 되지 않는다.


        ->  let restul = [];
            for(let i=0; i<ar.length; i++){ // 데이터가 3개 일 때, 3번의 true가 나오고 false가 나올 때 비로소 종료한다고 이해.
                result.push(ar[i] + 5);
            }
        -> 틀린 구조는 아니지만 index를 사용하는 것은 비효율 적일 수 있다.

        ->  let restul = [];
            let size = ar.length
            for(let i=0; i<size; i++){ 
                result.push(ar[i] + 5);
            }
        -> 위의 방법과 동일하나 ar.length를 위해 접근하는 횟수를 감소 시켜 접근횟수에서 이득을 본다.

        -> let ar = [10, 20 ,30];
           let result = ar.map((e) => {return e+5}); 
        ->  ar.map(e => return e+5); 도 가능, 매개변수 1개, 수행할 문장 1줄 일때 또한 return이 없으면 람다는 마지막 수행한 것 반환.

    2) 배열 순회중 .map()을 이용한 출력요소 만들고 App.js를 통해 배열 순회요소를 담은 컴포넌트 출력 
    [/src/component/Iteration.jsx]
        import React from 'react'

        const Iteration = () => {
            const names = ['Java Script', 'JAVA', 'Python', 'C#', 'GO', 'Rust'];

            // 배열 names를 순회(각 요소를 차례대로) 하면서 <li>태그로 감싸 nameList에 반환
            const namesList = names.map(name => <li>{name}</li>)

            return (
                <ul>
                    {namesList}
                </ul>
            )
        }

        export default Iteration;

    [App.js]
        import React from 'react'
        import Iteration from './component/Iteration'

        const App = () => {
            return (
                <div>
                    <Iteration/>
                </div>
            )
        }

        export default App

        => 실행 후 확인을 하면 출력은 되나 콘솔창에 에러가 있다.
        => React에서는 Component 배열을 랜더링 할 때 어떤 원소에 변동이 있었는지 확인하기 위해서 Key값을 설정해야 한다.
        => Key를 설정하지 않으면 변동사항을 확인하기 위해서 배열 전체를 순회해야하지만 Key를 설정하면 더욱 빠르게 변동사항을 확인할 수 있다.
        => 배열에서는 일반적으로 index를 Key 로 설정하면 무난하다.

        => Iteration.jsx 의 배열이 Key를 갖도록 수정
    [/src/component/Iteration.jsx]
        import React from 'react'

        const Iteration = () => {
            const names = ['Java Script', 'JAVA', 'Python', 'C#', 'GO', 'Rust'];

            // 배열 names를 순회(각 요소를 차례대로) 하면서 <li>태그로 감싸 nameList에 반환
            const namesList = names.map((name, index) => <li key={index}>{name}</li>)

            return (
                <ul>
                    {namesList}
                </ul>
            )
        }

        export default Iteration;

    3) 유동적인 데이터 적용
    P.S. 
            props
            => 상위 컴포넌트가 하위 컴포넌트에게 데이터를 넘겨주고자 할 때 사용한다.

            state   
            => 컴포넌트 내에서 생성해서 수정과 삭제가 가능한 개체로 변경이 되면 컴포넌트를 리랜더링

            ref
            => 컴포넌트를 조작하고자 할 때 생성한다.

            .filter() 는 매개변수가 1개이고 boolean을 반환하는 함수를 매개변수로 대입하는데 함수의 결과가 true인 데이터만 모아서 다시 배열로 반환하는 함수이다.

        => state는 변경시 자동으로 component에 반영된다.
        => Iteration.jsx 파일을 Class 형 컴포넌트로 변환 후 nameList가  state를 받아와 이벤트에 따라 컴포넌트가 자동으로 변화되도록 수정

    [scr/component/Iteration.jsx]
        import React, { Component } from 'react'

        class Iteration extends Component {
            //const names = ['Java Script', 'JAVA', 'Python', 'C#', 'GO', 'Rust'];

            // 내용이 변경되면 컴포넌트를 리랜더링 하는 State를 생성한 것
            state = {
                names: ['Java Script'],
                name: ''
            }

            // input 에 입력하면 name state의 값을 변경하는 이벤트 처리 함수
            onChangeInput = (e) => {
                this.setState({
                    name:e.target.value
                })
            }

            // 버튼을 누르면 name의 값을 names에 추가하는 함수
            // push 대신에 배열을 복제해서 연결하는 concat 함수 사용
            onClickInsertBtn = (e) => {
                this.setState({
                    names: this.state.names.concat(this.state.name),
                    name: ''
                })
            }

            // 데이터 삭제 함수
            // index를 매개변수로 받아서 삭제
            onClickRemove = (index) => {

                // 예, 아니오로 대답할 수 있는 다이알로그 메시지 출력, 예면 true 아니오면 false를 반환
                let result = window.confirm("정말로 삭제");
                
                if(result === false){
                    // 취소를 누를시 그냥 제어를 반환함.
                    // 아무일 도 없다.
                    return;
                }

                // 중괄호 안의 것은 객체에서 실제로 가져온다는 뜻
                const {names} = this.state;

                // slice - 매개변수 2개 받아서 배열을 잘라내서 복제해 반환하는 함수
                // 매개 변수는 시작 위치와 마지막 위치를 대입
                /* this.setState({
                    names: [names.slice(0, index),
                    names.slice(index+1, names.length)]
                }) */

                // 넘어온 인덱스와 배열의 인덱스가 다른 것 만 추출한다.(삭제효과)
                this.setState({
                    names: names.filter((item, e) => e !== index)
                })
            }


            render() {
                const nameList = this.state.names.map(
                    (name, index) =>
                        <li key={index}>
                            {name}
                            <button onClick={(e) => this.onClickRemove(index)}>삭제</button>
                        </li>);

                return (
                    <div>
                        <input onChange={this.onChangeInput} value={this.state.name}/>
                        <button onClick={this.onClickInsertBtn}>추가</button>
                        <ul>{nameList}</ul>
                    </div>
                )
            }
        }

        export default Iteration;

2. Life Cycle(생명주기)
    => 인스턴스가 생성되고 소멸될 때 까지의 과정을 의미한다.
    => 생성은 생성자(Constructor)가 담당하고 소멸은 소멸자(DeStructor가 담당한다.
    => IoC(Inversion of Control - 제어의 역전)
        -> 클래스는 개발자가 생성하지만 인스턴스의 생성과 소멸은 개발자가 아닌 다른 프레임워크나 컨테이너 등이 하는 형태를 의미한다.
        -> IoC 을 준수할때 특별한 경우가 아니면 생성자를 직접생성하지 않는다.
    
    => React에서 컴포넌트는 IoC가 적용되는 객체이다.
        -> Ex> 클래스형이나 함수형 컴포넌트를 만들고 Entry Point(App.js)에서 불러올 때 인스턴스를 생성자로 생성하지 않고 바로 사용하는 것.
    => 안드로이드나 react는 IoC가 적용된 객체를 Component라 하고 Spring 에서는 Spring Bean 이라고 한다.

    => IoC가 적용되면 일반적으로 생성자를 직접 호출하지 않기 때문에 수명주기 관련 메서드를 이용해 생성과 소멸될 때의 작업을 수행한다.

    1) React Component의 생명주기
        => Mount(컴포넌트가 메모리 할당을 받아서 출력) -> Update(컴포넌트 정보를 업데이트 하는 것으로 리랜더링) -> Unmount(컴포넌트가 화면에서 제거)

    2) Mount 시 호출되는 메서드
        - constructor
            생성자로 가장 먼저 호출된다.
            state 초기화를 수행한다. (객체지향 언어에서도 비슷하게 속성들을 초기화하는 작업을 수행한다.)

        - getDrivedStateFromProps
            props에 있는 값을 stete에 동기화 할 때 호출
        
        - render
            랜더링(화면에 그리는 것) 할 때 호출되는 메서드로 this.props와 this.state를 이용해서 props와 state에 접근이 가능하다.
            데이터를 받아오는 작업을 랜더시 같이 하면 데이터 가져오기 전까지 랜더링이 안될 가능성이 있어서 랜더링 시 데이터를 받아오는 작업은 매우 지양한다

        - componentDidMount
            화면에 보여지고 난 후 호출되는 메서드
            비동기 작업(네트워크 사용, 타이머 작업등)을 수행한다.

    3) Update 시 호출되는 메서드
        - getDrivedStateFromProps
            props에 있는 값을 stete에 동기화 할 때 호출

        - shouldComponentUpdate
            리랜더링을 결정하는 메서드로 해당 메서드가 false를 반환하면 리랜더링 되지 않는다.

        - render
            랜더링(화면에 그리는 것) 할 때 호출되는 메서드

        - getSnapshotBeforeUpdate
            변경된 내용(snapshot)을 DOM에 적용하기 직전에 호출되는 메서드
            Git에서 main branch 말고 사용자가 만든 임의의 brach에 변경내용을 먼저 올려두고 원본에 변경된 내용을 반영할 때 사용하는 원리와 비슷

        - componentDidUpdate
            업데이트 된 후 호출되는 메서드

    4) Unmount 시 호출되는 메서드
        - componentWillUnmount
            사라지기 전에 호출되는 메서드
            memory leak(메모리 누수)가 발생할 수 있는 객체(Ex> 타이머, 루프되는 객체)의 제거 작업을 수행한다.
    
    5) life Cycle 사용시 주의사항
        => react의 개발모드가 React.StrictMode로(index.js 확인가능) 설정되어 있으면 개발 환경에서는 Mount를 두번 수행한다.(운영시에는 한번)

3. 에러를 화면에 출력
    1) 에러를 발생시키기 위해서 Iteration.jsx 파일에서 없는 properties를 출력
        {this.satate.Err.value} {/* 컴파일러에 보이지 않지만 브라우저에서는 학인 할 수 있는 에러 */}
        
    2) state 관련된 에러가 발생해하면 호출되는 메서드를 재정의해서 에러가 발생했다는 사실을 출력해주는 컴포넌트 ErrorBoundary.jsx 생성

4. Hooks
    => React 16.8 version 이상 부터 지원
    => Class Component의 기능을 Function Component에서 사용할 수 있도록 해주는 기능이다.
    => useState, useHistory, useEffect, useRef, ....
    
5. useState
    => state를 함수 컴포넌트 안에서 사용할 수 있도록 해주는 hook이다.
    => useState의 매개 변수는 state의 초기값이 되고 반환하는 데이터는 state와 state의 값을 변경할 수 있는 setter 함수의 배열이다.

    1) 클래스형 컴포넌트와 클래스형 컴포넌트의 기능을 동일하게 해서 비교
    [App.js]
        import React, { Component, useState } from 'react';
        import ErrorBoundary from './component/ErrorBoundary'
        import Iteration from './component/Iteration'

        // 클래스 형 컴포넌트
        class ClassState extends Component {

        /*
        // 생성자를 만들지 않고 초기화가 가능하다.
        state = { // JS 문법이 아님(React에서 사용하는 방식)
            count : 0
        } 
        */

        // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
        constructor(props) {
            super(props);
            this.state = {
            count: 0
            }
        }

        render() {
            return (
            <div>
                <p>클릭을 {this.state.count} 번 수행</p>
                <button onClick={
                (e) => {
                    this.setState({
                    count: this.state.count + 1
                    })
                }}>
                클릭
                </button>
            </div>
            )
        }
        }


        // 함수형 컴포넌트
        const FucnState = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>클릭을 {count}번 수행했습니다.</p>
            <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
            </div>
        )
        }


        const App = () => {
        return (
            <div>
            {/* <ErrorBoundary>
                <Iteration />
            </ErrorBoundary> */}

            <ClassState />
            <FucnState/>
            </div>
        )
        }

        export default App

6. useRef
    => ref란 컴포넌트를 조작하기 위해서 붙이는 일종의 id와 같은 변수를 의미한다.
    => useRef로 만들어진 변수는 useState로 만들어진 변수와 달리 변경된다고 해서 컴포넌트가 리랜더링 되지는 않는다.
    => useRef(초기값) 으로 변수를 생성하고 컴포넌트나 DOM에 설정할 때는 ref 속성에 생성된 변수를 대입해주면 된다.

    => 특정 Input에 focus 설정하기
    [src/component/FuncRef.jsx]
        import React, {useState, useRef} from 'react'

        const FuncRef = () => {
            const [userName, setUserName] = useState("")
            const [nickName, setNickName] = useState("")

            // react에서 다른 component나 DOM을 참조할 수 있는 변수를 생성
            const nameInput = useRef();


            // input에 입력된 값으로 useState의 속성의 값들을 전달하는 함수 
            const onchangeUserNameInput = (e) => {
                setUserName(e.target.value)
            }

            const onchangeNickrNameInput = (e) => {
                setNickName(e.target.value)
            }

            const onClickResetBtn = (e) =>{
                alert(`name : ${userName}\nnickname : ${nickName}`)
                setUserName("");
                setNickName("")
                
                // useRef를 이용해 이름 입력란으로 focus 설정
                nameInput.current.focus();
            }

        return (
            <div>
                {/* 하나의 useState에 2개 이상의 속성을 다룬다면 사용할 tag에 name 속성의 값을 useState의 속성이름과 매칭 시킨다. */}
                <input name='username' type='text' value={userName} onChange={onchangeUserNameInput} ref={nameInput}/><br/>
                <input name='nickname' type='text' value={nickName} onChange={onchangeNickrNameInput}/><br/>
                <button onClick={onClickResetBtn}>초기화</button>
            </div>
        )
        }

        export default FuncRef

    [App.js]
        import React, { Component, useState } from 'react';
        import ErrorBoundary from './component/ErrorBoundary'
        import Iteration from './component/Iteration'
        import FuncRef from './component/FuncRef';

        // 클래스 형 컴포넌트 state
        class ClassState extends Component {

        /*
        // 생성자를 만들지 않고 초기화가 가능하다.
        state = { // JS 문법이 아님(React에서 사용하는 방식)
            count : 0
        } 
        */

        // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
        constructor(props) {
            super(props);
            this.state = {
            count: 0
            }
        }

        render() {
            return (
            <div>
                <p>클릭을 {this.state.count} 번 수행</p>
                <button onClick={
                (e) => {
                    this.setState({
                    count: this.state.count + 1
                    })
                }}>
                클릭
                </button>
            </div>
            )
        }
        }


        // 함수형 컴포넌트 state
        const FucnState = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>클릭을 {count}번 수행했습니다.</p>
            <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
            </div>
        )
        }

        const App = () => {
        return (
            <div>
            {/* <ErrorBoundary>
                <Iteration />
            </ErrorBoundary> */}

            <ClassState />
            <FucnState/>
            <br/>
            <FuncRef/>
            <br/>
        
            </div>
        )
        }

        export default App

7. useEffect
    => state가 변경된 후 수행할 side effect를 설정하는 Hook이다.
    => Class의 Life Cycle 중에 componentDidMount와 componentDidUpdate, componentWillUnmount가 합쳐진 형태이다.

    1) Class LifeCycle과 Effect 확인
    => App.js 에 ClassEffect 클래스형 컴포넌트 생성해서 확인
    [App.js]
        import React, { Component, useState } from 'react';
        import ErrorBoundary from './component/ErrorBoundary'
        import Iteration from './component/Iteration'
        import FuncRef from './component/FuncRef';

        // 클래스 형 컴포넌트 state
        class ClassState extends Component {

        /*
        // 생성자를 만들지 않고 초기화가 가능하다.
        state = { // JS 문법이 아님(React에서 사용하는 방식)
            count : 0
        } 
        */

        // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
        constructor(props) {
            super(props);
            this.state = {
            count: 0
            }
        }

        render() {
            return (
            <div>
                <p>클릭을 {this.state.count} 번 수행</p>
                <button onClick={
                (e) => {
                    this.setState({
                    count: this.state.count + 1
                    })
                }}>
                클릭
                </button>
            </div>
            )
        }
        }


        // 함수형 컴포넌트 state
        const FucnState = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>클릭을 {count}번 수행했습니다.</p>
            <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
            </div>
        )
        }


        class ClassEffect extends Component{
        // 생성자
        constructor(props){
            super(props);
            console.log("가장 먼저 호출되는 메서드")

            this.state = {
            count: 0
            }
        }
            // Component가 Mount된 후 호출되는 메서드
            componentDidMount(){
            console.log("마운트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} times`
            }

            // component가 Update된 후 호출되는 메서드
            componentDidUpdate(){
            console.log("업데이트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} time`
            }
            render(){
            return(
                <div>
                <p>You clicked {this.state.count} times</p>
                </div>
            )
            }
        }

        const App = () => {
        return (
            <div>
            {/* <ErrorBoundary>
                <Iteration />
            </ErrorBoundary> */}

            <ClassState />
            <FucnState/>
            <br/>
            <FuncRef/>
            <br/>
            <ClassEffect/>
            </div>
        )
        }

        export default App

        => 실행하고 콘솔을 확인하면 생성자와 마운트가 2번 되는 것을 확인할 수 있는데 이는 개발 환경에서 StrictMode 가 적용되어 그렇다.

    2) useEffect 를 통해 함수형 컴포넌트에서 Effect 사용하기
    [/src/component/FuncEffect.jsx]
        import React, {useState, useEffect} from 'react'

        const FrucEffect = () => {
            // Class형 컴포넌트 Effect에서 생성자 초기화와 같은 역할
            const [count, setCount] = useState(0);

            useEffect(() => {
                console.log("마운트와 업데이트가 끝나면 호출")
                document.title = `You clicked ${count} times`
            },[])

        return (
            <div>
                <p>You clicked {count} times</p>
                <button onClick={(e) => setCount(count + 1)}>클릭</button>
            </div>
        )
        }

        export default FrucEffect

    [App.js]
        import React, { Component, useState } from 'react';
        import ErrorBoundary from './component/ErrorBoundary'
        import Iteration from './component/Iteration'
        import FuncRef from './component/FuncRef';
        import FuncEffect from './component/FrucEffect'

        // 클래스 형 컴포넌트 state
        class ClassState extends Component {

        /*
        // 생성자를 만들지 않고 초기화가 가능하다.
        state = { // JS 문법이 아님(React에서 사용하는 방식)
            count : 0
        } 
        */

        // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
        constructor(props) {
            super(props);
            this.state = {
            count: 0
            }
        }

        render() {
            return (
            <div>
                <p>클릭을 {this.state.count} 번 수행</p>
                <button onClick={
                (e) => {
                    this.setState({
                    count: this.state.count + 1
                    })
                }}>
                클릭
                </button>
            </div>
            )
        }
        }


        // 함수형 컴포넌트 state
        const FucnState = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>클릭을 {count}번 수행했습니다.</p>
            <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
            </div>
        )
        }


        class ClassEffect extends Component{
        // 생성자
        constructor(props){
            super(props);
            console.log("가장 먼저 호출되는 메서드")

            this.state = {
            count: 0
            }
        }
            // Component가 Mount된 후 호출되는 메서드
            componentDidMount(){
            console.log("마운트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} times`
            }

            // component가 Update된 후 호출되는 메서드
            componentDidUpdate(){
            console.log("업데이트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} time`
            }
            render(){
            return(
                <div>
                <p>You clicked {this.state.count} times</p>
                <button onClick={(e) => this.setState({count: this.state.count + 1})}>클릭</button>
                </div>
            )
            }
        }

        const App = () => {
        return (
            <div>
            {/* <ErrorBoundary>
                <Iteration />
            </ErrorBoundary> */}

            {/* <ClassState />
            <FucnState/>
            <br/>
            <FuncRef/>
            <br/> */}

            {/* <ClassEffect/><br/> */}
            <FuncEffect/>
            </div>
        )
        }

        export default App
    
    3) useEffect 함수
        => useEffect(() => {수행할 내용}, [deps 배열]) 이 원형이다.
            -> deps 배열을 생략하면 Mount 될 때 와 모든 state가 변경될 때 마다 호출된다.
            -> deps 배열을 비워두면 Mount 된 후 1회만 호출된다.
            -> deps 배열에 state를 설정하면 Mount 될 때와 해당 state 값이 변경될 때마다 호출된다.

        => 수행할 내용에서 함수를 반환(return)하면 clean up 함수가 된다.
            -> clena up 함수는 Unmount될 때 호출되는 함수이다.

8. 객체 배열을 함수형 컴포넌트로 출력하고 삽입, 삭제, 갱신 수행하기

    1) 하나의 객체를 출력할 컴포넌트와 객체 배열을 출력할 컴포넌트를 작성 - UserList.jsx
        - 앞서 App.js 사용한 컴포넌트들은 모두 주석처리 후 진행

    [/src/component/UserList.jsx]
        import React from 'react'

        const User = ({user}) => {
        return (
            <div>
                <b>{user.username}</b>
                <span>({user.email})</span>
            </div>
        )
        }

        export const UserList = ({users}) => {
        return (
            <div>
                {users.map(user => <User user={user} key={user.id}/>)}
            </div>
        ) 
        }


        export default UserList

    2) App.js에서 기본 데이터를 작성하고 출력할 수 있도록 작성
        => 하위 컴포넌트에서도 사용되는 데이터는 꼭 App.js가 아니더라도 같은 데이터를 사용하는 컴포넌트들의 root에 위치하는 것이 좋다.
    [App.js]
        import React, { Component, useState } from 'react';
        import UserList from './component/UserList';
        /* import ErrorBoundary from './component/ErrorBoundary'
        import Iteration from './component/Iteration'
        import FuncRef from './component/FuncRef';
        import FuncEffect from './component/FrucEffect' */

        /* // 클래스 형 컴포넌트 state
        class ClassState extends Component {

        
        // 생성자를 만들지 않고 초기화가 가능하다.
        state = { // JS 문법이 아님(React에서 사용하는 방식)
            count : 0
        } 
        

        // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
        constructor(props) {
            super(props);
            this.state = {
            count: 0
            }
        }

        render() {
            return (
            <div>
                <p>클릭을 {this.state.count} 번 수행</p>
                <button onClick={
                (e) => {
                    this.setState({
                    count: this.state.count + 1
                    })
                }}>
                클릭
                </button>
            </div>
            )
        }
        } */


        /* // 함수형 컴포넌트 state
        const FucnState = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>클릭을 {count}번 수행했습니다.</p>
            <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
            </div>
        )
        } */


        /* class ClassEffect extends Component{
        // 생성자
        constructor(props){
            super(props);
            console.log("가장 먼저 호출되는 메서드")

            this.state = {
            count: 0
            }
        }
            // Component가 Mount된 후 호출되는 메서드
            componentDidMount(){
            console.log("마운트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} times`
            }

            // component가 Update된 후 호출되는 메서드
            componentDidUpdate(){
            console.log("업데이트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} time`
            }
            render(){
            return(
                <div>
                <p>You clicked {this.state.count} times</p>
                <button onClick={(e) => this.setState({count: this.state.count + 1})}>클릭</button>
                </div>
            )
            }
        }
        */


        const App = () => {
        const users = [
            {id: 1, username: "adam", email: "itawe@awef.dcc"},
            {id: 2, username: "eve", email: "few@awef.dcc"},
            {id: 3, username: "군계", email: "mon@awef.dcc"}
        ]
        return (
            <div>
            <UserList users={users}/>

            {/* <ErrorBoundary>
                <Iteration />
            </ErrorBoundary> */}

            {/* <ClassState />
            <FucnState/>
            <br/>
            <FuncRef/>
            <br/> */}

            {/* <ClassEffect/><br/> */}
            {/* <FuncEffect/> */}
            </div>
        )
        }

        export default App

    3) 데이터 추가 구현
        => 추가 화면에 해당하는 컴포넌트 생성 - CreateUser.jsx
        => 기본데이터는 App.js에 존재하므로 실제 데이터 추가는 App.js로 추가해야한다.
        => 이런 경우 App.js state나 이벤트 핸들러를 만들고 CreateUser.jsx에게 props 형태로 전달해서 사용하는 것이 편리하다.

        [/src/component/CreateUser.jsx]
            import React from 'react'

            const CreateUser = ({username, email, onChangeInput, onCreateBtn}) => {
                
            return (
                
                <div>
                    <input name='username' value={username} onChange={onChangeInput} placeholder='이름을 입력하세요.' type='text' />
                    <input name='email' value={email} onChange={onChangeInput} placeholder='이메일을 입력하세요' type='text'/>
                    <button onClick={onCreateBtn}>추가</button>
                </div>
            )
            }

            export default CreateUser

        [App.js]
            import React, { Component, useState, useRef } from 'react';
            import UserList from './component/UserList';
            import CreateUser from './component/CreateUser';
            /* import ErrorBoundary from './component/ErrorBoundary'
            import Iteration from './component/Iteration'
            import FuncRef from './component/FuncRef';
            import FuncEffect from './component/FrucEffect' */

            /* // 클래스 형 컴포넌트 state
            class ClassState extends Component {

            
            // 생성자를 만들지 않고 초기화가 가능하다.
            state = { // JS 문법이 아님(React에서 사용하는 방식)
                count : 0
            } 
            

            // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
            constructor(props) {
                super(props);
                this.state = {
                count: 0
                }
            }

            render() {
                return (
                <div>
                    <p>클릭을 {this.state.count} 번 수행</p>
                    <button onClick={
                    (e) => {
                        this.setState({
                        count: this.state.count + 1
                        })
                    }}>
                    클릭
                    </button>
                </div>
                )
            }
            } */


            /* // 함수형 컴포넌트 state
            const FucnState = () => {
            const [count, setCount] = useState(0);

            return (
                <div>
                <p>클릭을 {count}번 수행했습니다.</p>
                <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
                </div>
            )
            } */


            /* class ClassEffect extends Component{
            // 생성자
            constructor(props){
                super(props);
                console.log("가장 먼저 호출되는 메서드")

                this.state = {
                count: 0
                }
            }
                // Component가 Mount된 후 호출되는 메서드
                componentDidMount(){
                console.log("마운트 된 후 호출되는 메서드");
                document.title = `You clicked ${this.state.count} times`
                }

                // component가 Update된 후 호출되는 메서드
                componentDidUpdate(){
                console.log("업데이트 된 후 호출되는 메서드");
                document.title = `You clicked ${this.state.count} time`
                }
                render(){
                return(
                    <div>
                    <p>You clicked {this.state.count} times</p>
                    <button onClick={(e) => this.setState({count: this.state.count + 1})}>클릭</button>
                    </div>
                )
                }
            }
            */


            const App = () => {

            const [inputs, setInputs] = useState({
                username: "",
                email: ""
            })

            const {username, email} = inputs

            const onChangeInput = (e) =>{
                // 2개 이상의 state 속성(배열이나 객체이기 때문)를 수정할 때는 복제한 후 사용해야 한다.
                setInputs({
                ...inputs,
                [e.target.name]: e.target.value
                })
            }

            // users 샘플데이터
            // 배열의 데이터를 수정하면 컴포넌트가 리랜더링 될 수 있도록 state로 변환한 것.
            const [users, setUsers] = useState([
                {id: 1, username: "adam", email: "itawe@awef.dcc"},
                {id: 2, username: "eve", email: "few@awef.dcc"},
                {id: 3, username: "군계", email: "mon@awef.dcc"}
            ]);

            // 변수를 생성
            const nextId = useRef(4);

            // 데이터 삽입 함수
            const onCreateBtn = () =>{
                // 하나의 user 객체를 생성
                const user = {
                id: nextId.current,
                username,
                email
                }

                // 생성한 user 객체를 users state에 추가
                setUsers([...users, user]);


                // Input 초기화
                setInputs({
                username:'',
                email:''
                })

                // 다음 Id를 위해서 id값을 1증가
                nextId.current += 1;
            }

            
            return (
                <div>
                <UserList users={users}/>
                <CreateUser username={username} email={email} onChangeInput={onChangeInput} onCreateBtn={onCreateBtn}/>

                {/* <ErrorBoundary>
                    <Iteration />
                </ErrorBoundary> */}

                {/* <ClassState />
                <FucnState/>
                <br/>
                <FuncRef/>
                <br/> */}

                {/* <ClassEffect/><br/> */}
                {/* <FuncEffect/> */}
                </div>
            )
            }

            export default App
    
    4) 데이터 삭제
        => 데이터 
        => UserList.jsx, App.js 수정

    [App.js]
        import React, { Component, useState, useRef } from 'react';
        import UserList from './component/UserList';
        import CreateUser from './component/CreateUser';
        /* import ErrorBoundary from './component/ErrorBoundary'
        import Iteration from './component/Iteration'
        import FuncRef from './component/FuncRef';
        import FuncEffect from './component/FrucEffect' */

        /* // 클래스 형 컴포넌트 state
        class ClassState extends Component {

        
        // 생성자를 만들지 않고 초기화가 가능하다.
        state = { // JS 문법이 아님(React에서 사용하는 방식)
            count : 0
        } 
        

        // JS 문법에서 생성자를 만들어서 인스턴스를 초기화 하는 방식
        constructor(props) {
            super(props);
            this.state = {
            count: 0
            }
        }

        render() {
            return (
            <div>
                <p>클릭을 {this.state.count} 번 수행</p>
                <button onClick={
                (e) => {
                    this.setState({
                    count: this.state.count + 1
                    })
                }}>
                클릭
                </button>
            </div>
            )
        }
        } */


        /* // 함수형 컴포넌트 state
        const FucnState = () => {
        const [count, setCount] = useState(0);

        return (
            <div>
            <p>클릭을 {count}번 수행했습니다.</p>
            <button onClick={(e) => setCount(count + 1)}> 클릭 </button>
            </div>
        )
        } */


        /* class ClassEffect extends Component{
        // 생성자
        constructor(props){
            super(props);
            console.log("가장 먼저 호출되는 메서드")

            this.state = {
            count: 0
            }
        }
            // Component가 Mount된 후 호출되는 메서드
            componentDidMount(){
            console.log("마운트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} times`
            }

            // component가 Update된 후 호출되는 메서드
            componentDidUpdate(){
            console.log("업데이트 된 후 호출되는 메서드");
            document.title = `You clicked ${this.state.count} time`
            }
            render(){
            return(
                <div>
                <p>You clicked {this.state.count} times</p>
                <button onClick={(e) => this.setState({count: this.state.count + 1})}>클릭</button>
                </div>
            )
            }
        }
        */


        const App = () => {

        const [inputs, setInputs] = useState({
            username: "",
            email: ""
        })

        const {username, email} = inputs

        const onChangeInput = (e) =>{
            // 2개 이상의 state 속성(배열이나 객체이기 때문)를 수정할 때는 복제한 후 사용해야 한다.
            setInputs({
            ...inputs,
            [e.target.name]: e.target.value
            })
        }

        // users 샘플데이터
        // 배열의 데이터를 수정하면 컴포넌트가 리랜더링 될 수 있도록 state로 변환한 것.
        const [users, setUsers] = useState([
            {id: 1, username: "adam", email: "itawe@awef.dcc"},
            {id: 2, username: "eve", email: "few@awef.dcc"},
            {id: 3, username: "군계", email: "mon@awef.dcc"}
        ]);

        // 변수를 생성
        const nextId = useRef(4);

        // 데이터 삽입 함수
        const onCreateBtn = () =>{
            // 하나의 user 객체를 생성
            const user = {
            id: nextId.current,
            username,
            email
            }

            // 생성한 user 객체를 users state에 추가
            setUsers([...users, user]);


            // Input 초기화
            setInputs({
            username:'',
            email:''
            })

            // 다음 Id를 위해서 id값을 1증가
            nextId.current += 1;
        }

        // 데이터를 삭제하는 함수
        const onRemoveBtn = (id) =>{
            // users state 에서 id가 id인 데이터를 삭제
            // id가 일치하지 않는 데이터를 가지고 배열을 만들어서 수정하는 것.(실제로 삭제하는 것이 아니다.)
            setUsers(users.filter(user => user.id !== id));
        }
        
        return (
            <div>
            <UserList users={users} onRemoveBtn={onRemoveBtn}/>
            <CreateUser username={username} email={email} onChangeInput={onChangeInput} onCreateBtn={onCreateBtn}/>

            {/* <ErrorBoundary>
                <Iteration />
            </ErrorBoundary> */}

            {/* <ClassState />
            <FucnState/>
            <br/>
            <FuncRef/>
            <br/> */}

            {/* <ClassEffect/><br/> */}
            {/* <FuncEffect/> */}
            </div>
        )
        }

        export default App
    
    [/src/component/UserList.jsx]
        import React from 'react'

        const User = ({user, onRemoveBtn}) => {
        return (
            <div>
                <b>{user.username}</b>
                <span>({user.email})</span>
                <button onClick={(e) => onRemoveBtn(user.id)}>삭제</button>
            </div>
        )
        }

        export const UserList = ({users, onRemoveBtn}) => {
        return (
            <div>
                {users.map(user => <User user={user} key={user.id} onRemoveBtn={onRemoveBtn}/>)}
            </div>
        ) 
        }


        export default UserList

    5) 배열의 데이터를 수정
        => 계정이름을 클릭하면 active 속성 값을 toggle(반전)시켜서 글자 색상을 변경하도록 하기

        => App.js와  UserList.jsx 수정
    