[react_prac2]

1. 컴포넌트 반복
    => 동일한 모양의 컴포넌트를 여러개 배치
    => 배열 형태의 데이터를 출력할 때 유용하게 사용

    1) 배열.map() [변환]
    
        => 배열의 데이터를 순회하면서 매개변수로 받은 함수를 요소 단위로 수행한 후 그 결과를 모아서 다시 배열로 반환하는 함수이다.

        => .map()에 설정하는 매개 변수는 2개다.

            -> 첫번째는 callback 함수로 필수요소 이다.
                - callback 함수의 매개변수는 3개까지 될 수 있고 반드시 하나의 데이터를 반환해야한다.

                - 첫번째 매개 변수는 순회하는 각 요소
                - 두번째 매개 변수는 인덱스
                - 세번째 매개 변수는 배열 그 자체

            -> 두번째는 callback 함수 내부에서 사용할 this 참조로 선택요소이다.

    P.S 배열 작업시 속도 올리려면 map, filter, reduce, for each를 사용해라.

    Ex> let ar = [10, 20, 30] 에서 위의 배열에 5를 더한 배열을 생성한다.

        -> for(let i=0; i<ar.length; i++){
                ar[i] = ar[i] + 5;
            }
        -> React에서는 props나 state 값을 수정할 수 없기 때문에 이런 구조가 성립 되지 않는다.


        ->  let restul = [];
            for(let i=0; i<ar.length; i++){ // 데이터가 3개 일 때, 3번의 true가 나오고 false가 나올 때 비로소 종료한다고 이해.
                result.push(ar[i] + 5);
            }
        -> 틀린 구조는 아니지만 index를 사용하는 것은 비효율 적일 수 있다.

        ->  let restul = [];
            let size = ar.length
            for(let i=0; i<size; i++){ 
                result.push(ar[i] + 5);
            }
        -> 위의 방법과 동일하나 ar.length를 위해 접근하는 횟수를 감소 시켜 접근횟수에서 이득을 본다.

        -> let ar = [10, 20 ,30];
           let result = ar.map((e) => {return e+5}); 
        ->  ar.map(e => return e+5); 도 가능, 매개변수 1개, 수행할 문장 1줄 일때 또한 return이 없으면 람다는 마지막 수행한 것 반환.

    2) 배열 순회중 .map()을 이용한 출력요소 만들고 App.js를 통해 배열 순회요소를 담은 컴포넌트 출력 
    [/src/component/Iteration.jsx]
        import React from 'react'

        const Iteration = () => {
            const names = ['Java Script', 'JAVA', 'Python', 'C#', 'GO', 'Rust'];

            // 배열 names를 순회(각 요소를 차례대로) 하면서 <li>태그로 감싸 nameList에 반환
            const namesList = names.map(name => <li>{name}</li>)

            return (
                <ul>
                    {namesList}
                </ul>
            )
        }

        export default Iteration;

    [App.js]
        import React from 'react'
        import Iteration from './component/Iteration'

        const App = () => {
            return (
                <div>
                    <Iteration/>
                </div>
            )
        }

        export default App

        => 실행 후 확인을 하면 출력은 되나 콘솔창에 에러가 있다.
        => React에서는 Component 배열을 랜더링 할 때 어떤 원소에 변동이 있었는지 확인하기 위해서 Key값을 설정해야 한다.
        => Key를 설정하지 않으면 변동사항을 확인하기 위해서 배열 전체를 순회해야하지만 Key를 설정하면 더욱 빠르게 변동사항을 확인할 수 있다.
        => 배열에서는 일반적으로 index를 Key 로 설정하면 무난하다.

        => Iteration.jsx 의 배열이 Key를 갖도록 수정
    [/src/component/Iteration.jsx]
        import React from 'react'

        const Iteration = () => {
            const names = ['Java Script', 'JAVA', 'Python', 'C#', 'GO', 'Rust'];

            // 배열 names를 순회(각 요소를 차례대로) 하면서 <li>태그로 감싸 nameList에 반환
            const namesList = names.map((name, index) => <li key={index}>{name}</li>)

            return (
                <ul>
                    {namesList}
                </ul>
            )
        }

        export default Iteration;

    3) 유동적인 데이터 적용
    P.S. 
            props
            => 상위 컴포넌트가 하위 컴포넌트에게 데이터를 넘겨주고자 할 때 사용한다.

            state   
            => 컴포넌트 내에서 생성해서 수정과 삭제가 가능한 개체로 변경이 되면 컴포넌트를 리랜더링

            ref
            => 컴포넌트를 조작하고자 할 때 생성한다.

            .filter() 는 매개변수가 1개이고 boolean을 반환하는 함수를 매개변수로 대입하는데 함수의 결과가 true인 데이터만 모아서 다시 배열로 반환하는 함수이다.

        => state는 변경시 자동으로 component에 반영된다.
        => Iteration.jsx 파일을 Class 형 컴포넌트로 변환 후 nameList가  state를 받아와 이벤트에 따라 컴포넌트가 자동으로 변화되도록 수정

    [scr/component/Iteration.jsx]
        import React, { Component } from 'react'

        class Iteration extends Component {
            //const names = ['Java Script', 'JAVA', 'Python', 'C#', 'GO', 'Rust'];

            // 내용이 변경되면 컴포넌트를 리랜더링 하는 State를 생성한 것
            state = {
                names: ['Java Script'],
                name: ''
            }

            // input 에 입력하면 name state의 값을 변경하는 이벤트 처리 함수
            onChangeInput = (e) => {
                this.setState({
                    name:e.target.value
                })
            }

            // 버튼을 누르면 name의 값을 names에 추가하는 함수
            // push 대신에 배열을 복제해서 연결하는 concat 함수 사용
            onClickInsertBtn = (e) => {
                this.setState({
                    names: this.state.names.concat(this.state.name),
                    name: ''
                })
            }

            // 데이터 삭제 함수
            // index를 매개변수로 받아서 삭제
            onClickRemove = (index) => {

                // 예, 아니오로 대답할 수 있는 다이알로그 메시지 출력, 예면 true 아니오면 false를 반환
                let result = window.confirm("정말로 삭제");
                
                if(result === false){
                    // 취소를 누를시 그냥 제어를 반환함.
                    // 아무일 도 없다.
                    return;
                }

                // 중괄호 안의 것은 객체에서 실제로 가져온다는 뜻
                const {names} = this.state;

                // slice - 매개변수 2개 받아서 배열을 잘라내서 복제해 반환하는 함수
                // 매개 변수는 시작 위치와 마지막 위치를 대입
                /* this.setState({
                    names: [names.slice(0, index),
                    names.slice(index+1, names.length)]
                }) */

                // 넘어온 인덱스와 배열의 인덱스가 다른 것 만 추출한다.(삭제효과)
                this.setState({
                    names: names.filter((item, e) => e !== index)
                })
            }


            render() {
                const nameList = this.state.names.map(
                    (name, index) =>
                        <li key={index}>
                            {name}
                            <button onClick={(e) => this.onClickRemove(index)}>삭제</button>
                        </li>);

                return (
                    <div>
                        <input onChange={this.onChangeInput} value={this.state.name}/>
                        <button onClick={this.onClickInsertBtn}>추가</button>
                        <ul>{nameList}</ul>
                    </div>
                )
            }
        }

        export default Iteration;

2. Life Cycle(생명주기)
    => 인스턴스가 생성되고 소멸될 때 까지의 과정을 의미한다.
    => 생성은 생성자(Constructor)가 담당하고 소멸은 소멸자(DeStructor가 담당한다.
    => IoC(Inversion of Control - 제어의 역전)
        -> 클래스는 개발자가 생성하지만 인스턴스의 생성과 소멸은 개발자가 아닌 다른 프레임워크나 컨테이너 등이 하는 형태를 의미한다.
        -> IoC 을 준수할때 특별한 경우가 아니면 생성자를 직접생성하지 않는다.
    
    => React에서 컴포넌트는 IoC가 적용되는 객체이다.
        -> Ex> 클래스형이나 함수형 컴포넌트를 만들고 Entry Point(App.js)에서 불러올 때 인스턴스를 생성자로 생성하지 않고 바로 사용하는 것.
    => 안드로이드나 react는 IoC가 적용된 객체를 Component라 하고 Spring 에서는 Spring Bean 이라고 한다.

    => IoC가 적용되면 일반적으로 생성자를 직접 호출하지 않기 때문에 수명주기 관련 메서드를 이용해 생성과 소멸될 때의 작업을 수행한다.

    1) React Component의 생명주기
        => Mount(컴포넌트가 메모리 할당을 받아서 출력) -> Update(컴포넌트 정보를 업데이트 하는 것으로 리랜더링) -> Unmount(컴포넌트가 화면에서 제거)

    2) Mount 시 호출되는 메서드
        - constructor
            생성자로 가장 먼저 호출된다.
            state 초기화를 수행한다. (객체지향 언어에서도 비슷하게 속성들을 초기화하는 작업을 수행한다.)

        - getDrivedStateFromProps
            props에 있는 값을 stete에 동기화 할 때 호출
        
        - render
            랜더링(화면에 그리는 것) 할 때 호출되는 메서드로 this.props와 this.state를 이용해서 props와 state에 접근이 가능하다.
            데이터를 받아오는 작업을 랜더시 같이 하면 데이터 가져오기 전까지 랜더링이 안될 가능성이 있어서 랜더링 시 데이터를 받아오는 작업은 매우 지양한다

        - componentDidMount
            화면에 보여지고 난 후 호출되는 메서드
            비동기 작업(네트워크 사용, 타이머 작업등)을 수행한다.

    3) Update 시 호출되는 메서드
        - getDrivedStateFromProps
            props에 있는 값을 stete에 동기화 할 때 호출

        - shouldComponentUpdate
            리랜더링을 결정하는 메서드로 해당 메서드가 false를 반환하면 리랜더링 되지 않는다.

        - render
            랜더링(화면에 그리는 것) 할 때 호출되는 메서드

        - getSnapshotBeforeUpdate
            변경된 내용(snapshot)을 DOM에 적용하기 직전에 호출되는 메서드
            Git에서 main branch 말고 사용자가 만든 임의의 brach에 변경내용을 먼저 올려두고 원본에 변경된 내용을 반영할 때 사용하는 원리와 비슷

        - componentDidUpdate
            업데이트 된 후 호출되는 메서드

    4) Unmount 시 호출되는 메서드
        - componentWillUnmount
            사라지기 전에 호출되는 메서드
            memory leak(메모리 누수)가 발생할 수 있는 객체(Ex> 타이머, 루프되는 객체)의 제거 작업을 수행한다.
    
    5) life Cycle 사용시 주의사항
        => react의 개발모드가 React.StrictMode로(index.js 확인가능) 설정되어 있으면 개발 환경에서는 Mount를 두번 수행한다.(운영시에는 한번)

3. 에러를 화면에 출력
    1) 에러를 발생시키기 위해서 Iteration.jsx 파일에서 없는 properties를 출력
        {this.satate.Err.value} {/* 컴파일러에 보이지 않지만 브라우저에서는 학인 할 수 있는 에러 */}
        
    2) state 관련된 에러가 발생해하면 호출되는 메서드를 재정의해서 에러가 발생했다는 사실을 출력해주는 컴포넌트 ErrorBoundary.jsx 생성